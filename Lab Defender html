<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Lab Defender</title>
<style>
  :root{--bg:#071027;--panel:#0b2340;--player:#7be495;--enemy:#ff6b6b;--bullet:#cde7ff}
  *{box-sizing:border-box}
  body{margin:0;display:flex;min-height:100vh;align-items:center;justify-content:center;background:linear-gradient(180deg,var(--bg),#03101a);font-family:system-ui,Segoe UI,Roboto}
  #game{width:480px;height:720px;background:linear-gradient(#08243a,#04111a);border-radius:12px;overflow:hidden;box-shadow:0 8px 30px rgba(0,0,0,.6);position:relative}
  canvas{display:block;background:transparent}
  .hud{position:absolute;left:10px;top:10px;color:#cfe7ff;font-weight:600;letter-spacing:.6px}
  .hud span{display:inline-block;margin-right:12px}
  .centerMsg{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;flex-direction:column;color:#cfe7ff;pointer-events:none}
  button{margin-top:12px;padding:8px 14px;border-radius:8px;border:none;background:#1e90ff;color:white;font-weight:700;cursor:pointer;pointer-events:auto}
  .footer{position:absolute;bottom:8px;left:50%;transform:translateX(-50%);color:#98b7d6;font-size:12px}
</style>
</head>
<body>
<div id="game" role="application" aria-label="Lab Defender game">
  <canvas id="c" width="480" height="720"></canvas>
  <div class="hud"><span id="score">Score: 0</span><span id="lives">Lives: 3</span></div>
  <div class="centerMsg" id="center">
    <h1 style="margin:0;font-size:28px">Lab Defender</h1>
    <div style="opacity:.85;margin-top:6px">Move ← → or touch • Press Space to shoot</div>
    <button id="start">Start</button>
  </div>
  <div class="footer">Protect the lab — destroy spills & microbes!</div>
</div>

<script>
(() => {
  const canvas = document.getElementById('c'), ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  const startBtn = document.getElementById('start'), center = document.getElementById('center');
  const scoreEl = document.getElementById('score'), livesEl = document.getElementById('lives');

  // Game state
  let running = false, keys = {}, touchX = null;
  let player = {x: W/2, y: H-70, w: 80, h: 18, speed: 6};
  let bullets = [], enemies = [], spawnTimer = 0, spawnRate = 55;
  let score = 0, lives = 3, level = 1;

  // Helpers
  const rand = (a,b)=>Math.random()*(b-a)+a;
  const rectCircleCollide = (rx,ry,rw,rh,cx,cy,cr) => {
    const testX = Math.max(rx, Math.min(cx, rx+rw));
    const testY = Math.max(ry, Math.min(cy, ry+rh));
    const dx = cx-testX, dy = cy-testY;
    return (dx*dx+dy*dy) <= cr*cr;
  };

  function spawnEnemy(){
    const size = Math.floor(rand(12,34));
    enemies.push({
      x: rand(size, W-size),
      y: -size,
      r: size,
      vy: rand(1.2+level*0.25, 2.0+level*0.6),
      type: Math.random()<0.2? 'spill' : 'microbe' // for future variety
    });
  }

  function reset(){
    bullets = []; enemies = []; spawnTimer = 0; score = 0; lives = 3; level = 1;
    scoreEl.textContent = 'Score: 0'; livesEl.textContent = 'Lives: 3';
  }

  function start(){
    reset();
    running = true; center.style.display = 'none';
    requestAnimationFrame(loop);
  }

  function gameOver(){
    running = false;
    center.style.display = 'flex';
    center.querySelector('h1').textContent = 'Game Over';
    startBtn.textContent = 'Play Again';
    center.querySelector('div').textContent = `Score: ${score} • Level ${level}`;
  }

  // Input
  window.addEventListener('keydown', e=>keys[e.code]=true);
  window.addEventListener('keyup', e=>keys[e.code]=false);
  canvas.addEventListener('touchstart', e=>{
    touchX = e.touches[0].clientX - canvas.getBoundingClientRect().left;
    keys['Touch'] = true;
  },{passive:true});
  canvas.addEventListener('touchmove', e=>{
    touchX = e.touches[0].clientX - canvas.getBoundingClientRect().left;
  },{passive:true});
  canvas.addEventListener('touchend', ()=>{ touchX=null; keys['Touch']=false; });
  canvas.addEventListener('mousedown', e=>{
    touchX = e.clientX - canvas.getBoundingClientRect().left;
    keys['Touch'] = true;
  });
  window.addEventListener('mouseup', ()=>{ keys['Touch']=false; touchX=null; });
  startBtn.addEventListener('click', start);

  // Shooting cooldown
  let canShoot = true;
  function shoot(){
    if(!canShoot) return;
    bullets.push({x: player.x, y: player.y-12, r:6, vy:-7});
    canShoot = false;
    setTimeout(()=>canShoot=true, 200 - Math.min(120, level*8));
  }

  // Main loop
  function loop(){
    // Update
    if(keys['ArrowLeft'] || keys['KeyA']) player.x -= player.speed;
    if(keys['ArrowRight'] || keys['KeyD']) player.x += player.speed;
    if(keys['Space']) shoot();
    if(keys['Touch'] && touchX!=null) {
      // simple smoothing toward touch
      const tx = touchX;
      player.x += (tx - player.x) * 0.14;
      // auto-shoot when touching
      shoot();
    }

    // bounds
    player.x = Math.max(player.w/2, Math.min(W-player.w/2, player.x));

    // spawn
    spawnTimer++;
    if(spawnTimer > spawnRate){
      spawnEnemy();
      spawnTimer = 0;
      // gradually increase difficulty
      if(spawnRate > 20 && Math.random() < 0.27) spawnRate--;
    }

    // update bullets
    bullets.forEach(b => b.y += b.vy);
    bullets = bullets.filter(b=>b.y > -20);

    // update enemies
    enemies.forEach(e => e.y += e.vy);
    // collisions bullet vs enemy
    for(let i=enemies.length-1;i>=0;i--){
      for(let j=bullets.length-1;j>=0;j--){
        const e = enemies[i], b = bullets[j];
        const dx = e.x - b.x, dy = e.y - b.y;
        if(dx*dx + dy*dy < (e.r + b.r)*(e.r + b.r)){
          // hit
          enemies.splice(i,1);
          bullets.splice(j,1);
          score += Math.ceil(e.r/4);
          scoreEl.textContent = 'Score: ' + score;
          // level up
          if(score > level * 60){ level++; spawnRate = Math.max(20, spawnRate-4); }
          break;
        }
      }
    }

    // enemy reaches bottom or hits player
    for(let i=enemies.length-1;i>=0;i--){
      const e = enemies[i];
      if(e.y - e.r > H){
        enemies.splice(i,1);
        lives--;
        livesEl.textContent = 'Lives: ' + lives;
        if(lives<=0) return gameOver();
      } else if(rectCircleCollide(player.x - player.w/2, player.y - player.h/2, player.w, player.h, e.x, e.y, e.r)){
        enemies.splice(i,1);
        lives--;
        livesEl.textContent = 'Lives: ' + lives;
        if(lives<=0) return gameOver();
      }
    }

    // Draw
    ctx.clearRect(0,0,W,H);

    // background subtle grid
    ctx.save();
    ctx.globalAlpha = 0.06;
    ctx.strokeStyle = '#7fb0d8';
    for(let x=0;x<W;x+=32){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke(); }
    for(let y=0;y<H;y+=32){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke(); }
    ctx.restore();

    // player (beaker)
    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--player');
    ctx.beginPath();
    // beaker body
    ctx.roundRect(player.x - player.w/2, player.y - player.h/2, player.w, player.h, 6);
    ctx.fill();
    // beaker neck
    ctx.fillRect(player.x-12, player.y-50, 24, 34);
    ctx.fillStyle = 'rgba(255,255,255,0.08)';
    ctx.fillRect(player.x-12, player.y-50, 24, 6); // rim
    // liquid inside
    ctx.fillStyle = 'rgba(0,0,0,0.06)';
    ctx.fillRect(player.x - player.w/2 + 6, player.y - 4, player.w - 12, 6);

    // bullets
    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--bullet');
    bullets.forEach(b=>{
      ctx.beginPath(); ctx.arc(b.x, b.y, b.r, 0, Math.PI*2); ctx.fill();
    });

    // enemies
    enemies.forEach(e=>{
      ctx.beginPath();
      ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--enemy');
      ctx.arc(e.x, e.y, e.r, 0, Math.PI*2);
      ctx.fill();
      // microbe eyes / spots
      ctx.fillStyle = 'rgba(255,255,255,0.18)';
      ctx.beginPath(); ctx.arc(e.x - e.r*0.28, e.y - e.r*0.18, Math.max(2, e.r*0.18), 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc(e.x + e.r*0.2, e.y + e.r*0.08, Math.max(2, e.r*0.14), 0, Math.PI*2); ctx.fill();
      // little spikes for style
      ctx.strokeStyle = 'rgba(0,0,0,0.06)';
      ctx.beginPath();
      for(let a=0;a<8;a++){
        const ang = a/8 * Math.PI*2;
        const sx = e.x + Math.cos(ang)*(e.r+4);
        const sy = e.y + Math.sin(ang)*(e.r+4);
        ctx.moveTo(e.x + Math.cos(ang)*e.r, e.y + Math.sin(ang)*e.r);
        ctx.lineTo(sx,sy);
      }
      ctx.stroke();
    });

    // HUD small
    ctx.fillStyle = 'rgba(255,255,255,0.03)';
    ctx.fillRect(0,H-36,W,36);

    if(running) requestAnimationFrame(loop);
  }

  // small helper to enable roundRect on older contexts
  if(!CanvasRenderingContext2D.prototype.roundRect){
    CanvasRenderingContext2D.prototype.roundRect = function(x,y,w,h,r){
      if(typeof r==='number') r = {tl:r,tr:r,br:r,bl:r};
      this.beginPath();
      this.moveTo(x + r.tl, y);
      this.lineTo(x + w - r.tr, y);
      this.quadraticCurveTo(x + w, y, x + w, y + r.tr);
      this.lineTo(x + w, y + h - r.br);
      this.quadraticCurveTo(x + w, y + h, x + w - r.br, y + h);
      this.lineTo(x + r.bl, y + h);
      this.quadraticCurveTo(x, y + h, x, y + h - r.bl);
      this.lineTo(x, y + r.tl);
      this.quadraticCurveTo(x, y, x + r.tl, y);
      this.closePath();
    };
  }

  // accessibility: spacebar fire, enter start
  window.addEventListener('keydown', e=>{
    if(e.code === 'Enter' && !running) start();
    if(e.code === 'Space'){ e.preventDefault(); shoot(); }
  });

  // initial focus
  canvas.tabIndex = 0;
  canvas.style.outline = 'none';
})();
</script>
</body>
</html>
